/*
 * TODO: Update includes
 */
 <%
   # WARNING: This file should be probably be using CTypes to get function names.
   #          If you define a CType by hand, it probably won't match up with these
   #          generated functions.
 -%>
#include "mruby_<%= module_name %>.h"

<%
  concrete_classes = classes
    .reject { |c| c['is_template'] }
    .sort_by { |c| c['name']}
-%>

<% concrete_classes.each do |klass| -%>
#if BIND_<%= klass['ruby_name'] %>_TYPE
/*
 * Boxing implementation for <%= klass['name'] %>
 */

static void free_<%= klass['name'] %>(mrb_state* mrb, void* ptr) {
  mruby_to_native_ref* box = (mruby_to_native_ref*)ptr;
  if (box->belongs_to_ruby) {
    /* TODO: free is the default. Should be changed if a type-specific
     *       destructor is provided for this type.
     */
    if (box->obj != NULL) {
      free(box->obj);
      box->obj = NULL;
    }
  }
}

static const mrb_data_type <%= klass['name'].type_to_identifier %>_data_type = {
   "<%= klass['name'] %>", free_<%= klass['name'].type_to_identifier %>
};

mrb_value
mruby_box_<%= klass['name'].type_to_identifier %>(mrb_state* mrb, <%= klass['name'] %> *unboxed) {
  mruby_to_native_ref* box = (mruby_to_native_ref*)malloc(sizeof(mruby_to_native_ref));
  box->belongs_to_ruby = FALSE;
  box->obj = unboxed;
  return mrb_obj_value(Data_Wrap_Struct(mrb, <%= klass['ruby_name'] %>_class(mrb), &<%= klass['name'] %>_data_type, box));
}

mrb_value
mruby_giftwrap_<%= klass['name'].type_to_identifier %>(mrb_state* mrb, <%= klass['name'] %> *unboxed) {
   mruby_to_native_ref* box = (mruby_to_native_ref*)malloc(sizeof(mruby_to_native_ref));
   box->belongs_to_ruby = TRUE;
   box->obj = unboxed;
   return mrb_obj_value(Data_Wrap_Struct(mrb, <%= klass['ruby_name'] %>_class(mrb), &<%= klass['name'] %>_data_type, box));
}

void
mruby_set_<%= klass['name'].type_to_identifier %>_data_ptr(mrb_value obj, <%= klass['name'] %> *unboxed) {
  mruby_to_native_ref* box = (mruby_to_native_ref*)malloc(sizeof(mruby_to_native_ref));
  box->belongs_to_ruby = FALSE;
  box->obj = unboxed;
  mrb_data_init(obj, box, &<%= klass['name'] %>_data_type);
}

void
mruby_gift_<%= klass['name'].type_to_identifier %>_data_ptr(mrb_value obj, <%= klass['name'] %> *unboxed) {
  mruby_to_native_ref* box = (mruby_to_native_ref*)malloc(sizeof(mruby_to_native_ref));
  box->belongs_to_ruby = TRUE;
  box->obj = unboxed;
  mrb_data_init(obj, box, &<%= klass['name'] %>_data_type);
}

<%= klass['name'] %> *
mruby_unbox_<%= klass['name'].type_to_identifier %>(mrb_value boxed) {
  return (<%= klass['name'] %> *)((mruby_to_native_ref *)DATA_PTR(boxed))->obj;
}
#endif

<% end -%>
