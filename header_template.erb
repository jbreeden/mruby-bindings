<%
  concrete_classes = classes
    .reject { |c| c['is_template'] }
-%>

#ifndef <%= module_name %>_HEADER
#define <%= module_name %>_HEADER

/*
 * RClass Macros
 * -------------
 *
 * Macros for retrieving the RClass*'s defined by this gem.
 */

#define <%= module_name %>_module(mrb) mrb_module_get(mrb, "<%= module_name %>")
<% classes.each do |klass| -%>
#define <%= klass['ruby_name'] %>_class(mrb) mrb_class_get_under(mrb, <%= module_name %>_module(mrb), "<%= klass['ruby_name'] %>")
<% end -%>

/*
 * Class Bindings Options
 * ----------------------
 *
 * Use these macros to configure the generated bindings for classes & structs.
 *
 * Key:
 *
 * BIND_{type name}_TYPE                      : Should we bind the class at all?
 * BIND_{type name}_INITIALIZE                : If the class is bound, should we also bind initialize to malloc a new instance on `new`?
 * BIND_{type name}_{field name}_FIELD_READER : If the class is bound, should we also bind a reader for this field?
 * BIND_{type name}_{field name}_FIELD_WRITER : If the class is bound, should we also bind a writer for this field?
 * BIND_{type name}_{function name}_FUNCTION  : If the class is bound, should we also bind this member function?
 *
 * Fields & method are disabled by default so that bindings may be added and
 * tested incrementally. The generated bindings are a good start, but they
 * will need to be verified and, sometimes, customized.
 */

<% classes.each do |klass| -%>
#define BIND_<%= klass['ruby_name'] %>_TYPE TRUE
#define BIND_<%= klass['ruby_name'] %>_INITIALIZE FALSE
<%   klass['fields'].sort_by { |f| f['name'] }.each do |field| -%>
#define BIND_<%= klass['ruby_name'] %>_<%= field['name'] %>_FIELD_READER FALSE
#define BIND_<%= klass['ruby_name'] %>_<%= field['name'] %>_FIELD_WRITER FALSE
<%   end -%>
<%   klass['member_functions'].sort_by { |f| f['name'] }.each do |function| -%>
#define BIND_<%= klass['ruby_name'] %>_<%= function['name'] %>_FUNCTION FALSE
<%   end -%>

<% end -%>

/*
 * Global Function Options
 * -----------------------
 *
 * Set these macros to TRUE to enable bindings for these functions.
 * They are disabled initially so that bindings may be added and tested
 * incrementally. The generated bindings are a good start, but they
 * will need to be verified and, sometimes, customized.
 */

<% module_functions.each do |function| -%>
#define BIND_<%= function['name'] %>_FUNCTION FALSE
<% end -%>

/*
 * Header Files
 * ------------
 *
 * These are the header files that defined the
 * classes and functions for which bindings have
 * been generated. If any of these are not needed
 * they should be commented out.
 *
 * TODO: ONLY the filename is inserted here automatically.
 *       If the file is not directly on the include path,
 *       you will need to prepend the relative path.
 */

#include <stdlib.h>
#include "mruby.h"
#include "mruby/array.h"
#include "mruby/class.h"
#include "mruby/data.h"
#include "mruby/string.h"
#include "mruby/value.h"
#include "mruby/variable.h"
<%
classes.map { |c|
  File.basename(c['file'])
  }.concat(module_functions.map { |f|
    File.basename(f['file'])
  }).concat(macros.map { |m|
    File.basename(m['file'])
  }).uniq.sort.each do |file|
-%>
#include "<%= file %>"
<% end -%>

/*
 * Class initialization function declarations
 * ------------------------------------------
 *
 * These declarations are controlled by the macros in the
 * "Class Bindings Options" section above.
 */

<% classes.each do |klass| -%>
#if BIND_<%= klass['ruby_name'] %>_TYPE
void mrb_<%= module_name %>_<%= klass['ruby_name'] %>_init(mrb_state* mrb);
#endif
<% end -%>

/*
 * Boxing declarations
 * -------------------
 *
 * These declarations are controlled by the macros in the
 * "Class Bindings Options" section above.
 */

/*
* Extra wrapper over native pointer to indicate who owns this memory.
* (Either mruby, and it should be garage collected, or C, and it shouldn't be)
* Considered using the LSB of the pointer itself, but I don't think I can
* be assured that all memory is word-aligned (especially when C libraries
* implement their own memory management techniques like memory pools)
*/
typedef struct mruby_to_native_ref_ {
  /* If true, indicates that the object should be freed when
   * mruby GC's the ruby object containing this pointer. This
   * is set to true when an object is boxed via the `giftwrap`
   * or `gift_{type}_ptr_set` functions.
   */
  unsigned char belongs_to_ruby;

  /* A pointer to the native object */
  void* obj;

  /* For the convenience of the binding writer,
   * the data pointer can be used to associate arbitrary
   * data with a reference to a C object. This could
   * be a function pointer to invoke instead of `free` on GC,
   * a pointer back to the RObject, or even cast to an integer type
   * and used as a bit field. You get the idea...
   */
  void* data;
} mruby_to_native_ref;

<% concrete_classes.each do |klass| -%>
#if BIND_<%= klass['ruby_name'] %>_TYPE
mrb_value
mruby_box_<%= klass['name'].type_to_identifier %>(mrb_state* mrb, <%= klass['name'] %> *unboxed);

mrb_value
mruby_giftwrap_<%= klass['name'].type_to_identifier %>(mrb_state* mrb, <%= klass['name'] %> *unboxed);

void
mruby_set_<%= klass['name'].type_to_identifier %>_data_ptr(mrb_value obj, <%= klass['name'] %> *unboxed);

void
mruby_gift_<%= klass['name'].type_to_identifier %>_data_ptr(mrb_value obj, <%= klass['name'] %> *unboxed);

<%= klass['name'] %> *
mruby_unbox_<%= klass['name'].type_to_identifier %>(mrb_value boxed);
#endif

<% end -%>

/*
 * Macro definition function declaration
 * -------------------------------------
 */
void mruby_<%= module_name %>_define_macro_constants(mrb_state* mrb);

#endif
