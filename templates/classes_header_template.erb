#ifndef MRUBY_<%= module_name %>_CLASSES_HEADER
#define MRUBY_<%= module_name %>_CLASSES_HEADER

/*
 * Class Bindings Options
 * ----------------------
 *
 * Use these macros to configure the generated bindings for classes & structs.
 *
 * Key:
 *
 * BIND_{type name}_TYPE                      : Should we bind the class at all?
 * BIND_{type name}_INITIALIZE                : If the class is bound, should we also bind initialize to malloc a new instance on `new`?
 * BIND_{type name}_{field name}_FIELD_READER : If the class is bound, should we also bind a reader for this field?
 * BIND_{type name}_{field name}_FIELD_WRITER : If the class is bound, should we also bind a writer for this field?
 * BIND_{type name}_{function name}_FUNCTION  : If the class is bound, should we also bind this member function?
 *
 * Fields & method are disabled by default so that bindings may be added and
 * tested incrementally.
 */

<% classes.each do |klass| -%>
#define BIND_<%= klass['ruby_name'] %>_TYPE TRUE
#define BIND_<%= klass['ruby_name'] %>_INITIALIZE FALSE
<%   klass['fields'].sort_by { |f| f['name'] }.each do |field| -%>
#define BIND_<%= klass['ruby_name'] %>_<%= field['name'] %>_FIELD_READER FALSE
#define BIND_<%= klass['ruby_name'] %>_<%= field['name'] %>_FIELD_WRITER FALSE
<%   end -%>
<%   klass['member_functions'].sort_by { |f| f['name'] }.each do |function| -%>
#define BIND_<%= klass['ruby_name'] %>_<%= function['name'] %>_FUNCTION FALSE
<%   end -%>

<% end -%>

#endif
