/*
 * Boxing Code (Generated)
 * =======================
 *
 * The code generator learns the data types declared in the C/C++ source files
 * it is run against, and generates this boxing, unboxing, and GC code.
 * 
 * Terms
 * ------
 *
 * ### Boxing
 * In general refers to wrapping a native object in an mrb_value.
 * 
 * ### Gift Wrapping
 * A specific type of boxing, indicating that the object belongs
 * to Ruby and should be free'd when the mrb_value is GC'ed.
 * 
 * ### Unboxing
 * Retrieving the wrapped native object from an mrb_value.
 *
 * Customizing
 * -----------
 * 
 * By default, all data types are assumed to be destructable by the `free`
 * function. To use a custom destructor for your type, tell CTypes with
 * `CTypes.set_destructor`.
 *
 * Example
 * ```
 * // I have `struct GError` objects from glib,
 * // which should be freed with `g_error_free`
 * CTypes.set_destructor('struct GError', 'g_error_free')
 * ```
 */
#include "mruby_<%= module_name %>.h"

<%
  concrete_classes = classes
    .reject { |c| c['is_template'] }
    .sort_by { |c| c['name'] }
-%>

<% concrete_classes.each do |klass| -%>
<%   ctype = CTypes[klass['name']] -%>
<%   class_id = MRubyBindings.type_name_to_id(klass['name']) -%>
/* MRUBY_BINDING: <%= klass['ruby_name'] %>_boxing */
#if BIND_<%= klass['ruby_name'] %>_TYPE
/*
 * Boxing implementation for <%= klass['name'] %>
 */

static void free_<%= class_id %>(mrb_state* mrb, void* ptr) {
  mruby_to_native_ref* box = (mruby_to_native_ref*)ptr;
  if (box->belongs_to_ruby) {
    if (box->obj != NULL) {
      <%= CTypes.get_destructor(klass['name']) %>(box->obj);
      box->obj = NULL;
    }
  }
  free(box);
}

static const mrb_data_type <%= class_id %>_data_type = {
   "<%= klass['name'] %>", free_<%= class_id %>
};

mrb_value
mruby_box_<%= class_id %>(mrb_state* mrb, <%= klass['name'] %> *unboxed) {
  mruby_to_native_ref* box = (mruby_to_native_ref*)malloc(sizeof(mruby_to_native_ref));
  box->belongs_to_ruby = FALSE;
  box->obj = unboxed;
  return mrb_obj_value(Data_Wrap_Struct(mrb, <%= klass['ruby_name'] %>_class(mrb), &<%= class_id %>_data_type, box));
}

mrb_value
mruby_giftwrap_<%= class_id %>(mrb_state* mrb, <%= klass['name'] %> *unboxed) {
   mruby_to_native_ref* box = (mruby_to_native_ref*)malloc(sizeof(mruby_to_native_ref));
   box->belongs_to_ruby = TRUE;
   box->obj = unboxed;
   return mrb_obj_value(Data_Wrap_Struct(mrb, <%= klass['ruby_name'] %>_class(mrb), &<%= class_id %>_data_type, box));
}

void
mruby_set_<%= class_id %>_data_ptr(mrb_value obj, <%= klass['name'] %> *unboxed) {
  mruby_to_native_ref* box = (mruby_to_native_ref*)malloc(sizeof(mruby_to_native_ref));
  box->belongs_to_ruby = FALSE;
  box->obj = unboxed;
  mrb_data_init(obj, box, &<%= class_id %>_data_type);
}

void
mruby_gift_<%= class_id %>_data_ptr(mrb_value obj, <%= klass['name'] %> *unboxed) {
  mruby_to_native_ref* box = (mruby_to_native_ref*)malloc(sizeof(mruby_to_native_ref));
  box->belongs_to_ruby = TRUE;
  box->obj = unboxed;
  mrb_data_init(obj, box, &<%= class_id %>_data_type);
}

<%= klass['name'] %> *
mruby_unbox_<%= class_id %>(mrb_value boxed) {
  return (<%= klass['name'] %> *)((mruby_to_native_ref *)DATA_PTR(boxed))->obj;
}
#endif
/* MRUBY_BINDING_END */

<% end -%>
