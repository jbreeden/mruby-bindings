/*
 * <%= self['type']['type_name'] %>
 * Defined in file <%= File.basename self['file'] %> @ line <%= self['line'] %>
 */

#include "mruby_<%= module_name %>.h"

#if BIND_<%= self['ruby_name'] %>_TYPE

/* MRUBY_BINDING: header */
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::initialize */
#if BIND_<%= self['ruby_name'] %>_INITIALIZE
mrb_value
mrb_<%= module_name %>_<%= self['ruby_name'] %>_initialize(mrb_state* mrb, mrb_value self) {
<% # TODO: Add CTypes.set_initializer as dual of CTypes.set_destructor -%>
  mrb_raise(mrb, E_NOMETHOD_ERROR, "No initializer defined");
/* 
  <%= self['type']['type_name'] %>* native_object = (<%= self['type']['type_name'] %>*)calloc(1, sizeof(<%= self['type']['type_name'] %>));
  mruby_gift_<%= MRubyBindings.type_name_to_id(self['name']) %>_data_ptr(self, native_object);
  return self;
*/
}
#endif
/* MRUBY_BINDING_END */

<% if self['fields'].any? -%>
/*
 * Fields
 */

<%   self['fields'].select { |f| f['access'] == 'public' }.each do |field| -%>
/* MRUBY_BINDING: <%= self['ruby_name'] %>::<%= field['name'] %>_reader */
#if BIND_<%= self['ruby_name'] %>_<%= field['name'] %>_FIELD_READER
mrb_value
mrb_<%= module_name %>_<%= self['ruby_name'] %>_get_<%= field['name'] %>(mrb_state* mrb, mrb_value self) {
  <%= self['type']['type_name'] %> * native_self = mruby_unbox_<%= MRubyBindings.type_name_to_id(self['type']['type_name']) %>(self);

  <%= field['type']['type_name'] %> <%= field['ctype'].native_name(field['name']) %> = native_self-><%= field['name'] %>;

<%    field['ctype'].box(field['name']).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%    end -%>

  return <%= field['ctype'].ruby_name(field['name']) %>;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::<%= field['name'] %>_writer */
#if BIND_<%= self['ruby_name'] %>_<%= field['name'] %>_FIELD_WRITER
mrb_value
mrb_<%= module_name %>_<%= self['ruby_name'] %>_set_<%= field['name'] %>(mrb_state* mrb, mrb_value self) {
  <%= self['type']['type_name'] %> * native_self = mruby_unbox_<%= MRubyBindings.type_name_to_id(self['type']['type_name']) %>(self);
<%       field['ctype'].recv(field['name']).each_line do |line| -%>
  <%= line.sub("\n", '') %>
<%     end -%>

  mrb_get_args(mrb, "<%= field['ctype'].format_specifier %>", <%= field['ctype'].get_args_argv(field['name']) %>);

<% if (field['ctype'].type_check(field['name']).length > 0) && field['ctype'].needs_type_check?  -%>
  /* type checking */
<%    field['ctype'].type_check(field['name']).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%    end -%>

<%  end -%>
<% if field['ctype'].needs_unboxing? -%>
<%     field['ctype'].unbox(field['name']).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%     end -%>

<%   end -%>
<% field['ctype'].swap_fields("native_self->#{field['name']}", field['ctype'].native_name(field['name'])).each_line do |line| -%>
  <%= line.sub("\n", '') %>
<% end -%>
  
<% -%>
<% # Note: Don't do the unboxing cleanup. The native value is definitely still referenced by the underlying struct -%>
<% -%>
<% -%>
<% # Hacky way to return whatever was passed in. Mirrors typical assignment semantics -%>
<% -%>
  mrb_value value_as_mrb_value;
  mrb_get_args(mrb, "o", &value_as_mrb_value);
  return value_as_mrb_value;
}
#endif
/* MRUBY_BINDING_END */

<%   end -%>
<% end -%>

<% if self['member_functions'].any? -%>
/*
 * Methods
 */

<%   self['member_functions'].select { |f| f['access'] == 'public' }.each do |function| -%>
/* MRUBY_BINDING: <%= self['ruby_name'] %>::<%= function['name'] %> */
#if BIND_<%= self['ruby_name'] %>_<%= function['name'] %>_FUNCTION
#define <%= self['ruby_name'] %>_<%= function['name'] %>_REQUIRED_ARGC <%= function['argc'] %>
#define <%= self['ruby_name'] %>_<%= function['name'] %>_OPTIONAL_ARGC 0
/* <%= function['return_type']['type_name'] %> <%= function['name'] %>(<%= function['params'].map { |p| p['type']['type_name'] + ' ' + p['name'] }.join(', ') %>) */
mrb_value
mrb_<%= module_name %>_<%= self['ruby_name'] %>_<%= function['name'] %>(mrb_state* mrb, mrb_value self) {
  <%= self['type']['type_name'] %> * native_self = mruby_unbox_<%= self['type']['type_name'] %>(self);

<%   if function['params'].any? -%>
<%     function['params'].each do |param| -%>
  mrb_value <%= param['name'] %>;
<%     end -%>

/* Fetch the args */
  mrb_get_args(mrb, "<%= 'o' * function['params'].length %>", <%= function['params'].map { |p| "&#{p['name']}" }.join(', ') %>);

<%     if function['params'].any? %>
  /* Type checking */
<%       function['params'].each do |param| -%>
<%         (CTypes[param['type']['type_name']].type_check_template % ({:value => param['name']})).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%         end -%>
<%       end -%>
<%     end -%>

<%     if function['params'].any? %>
  /* Unbox parameters */
<%       function['params'].each do |param| -%>
<%         (CTypes[param['type']['type_name']].unboxing_fn.invocation_template % ({:unbox => param['name'], :as => "native_#{param['name']}"})).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%         end -%>

<%       end -%>
<%     end -%>
<%   end -%>
  /* Invocation */
  <%= function['return_type']['type_name'] == 'void' ? '' : "#{function['return_type']['type_name']} result = " %>native_self-><%= function['name'] %>(<%= function['params'].map { |p| "native_#{p['name']}" }.join(', ') %>);

<%   if function['return_type']['type_name'] != 'void' -%>
  /* Box the return value */
<%     (CTypes[function['return_type']['type_name']].boxing_fn.invocation_template % ({:box => 'result', :as => 'return_value'})).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%     end -%>

<%   end -%>
<%   function['params'].each do |param| -%>
<%     if CTypes[param['type']['type_name']].unboxing_fn.cleanup_template -%>
<%       (CTypes[param['type']['type_name']].unboxing_fn.cleanup_template % ({:value => "native_#{param['name']}"})).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%       end -%>

<%     end -%>
<%   end -%>
<%   if function['return_type']['type_name'] == 'void' -%>
  return mrb_nil_value();
<%   else -%>
  return return_value;
<%   end -%>
}
#endif
/* MRUBY_BINDING_END */

<%   end -%>
<% end -%>
void mrb_<%= module_name %>_<%= self['ruby_name'] %>_init(mrb_state* mrb) {
  static int initialized = 0;
  if (initialized) return;
  else initialized = 1;

/* MRUBY_BINDING: pre_class_definition */
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::class_definition */
  struct RClass* <%= self['ruby_name'] %>_class = mrb_define_class_under(mrb, <%= module_name %>_module(mrb), "<%= self['ruby_name'] %>", mrb->object_class);
  MRB_SET_INSTANCE_TT(<%= self['ruby_name'] %>_class, MRB_TT_DATA);
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::pre_class_method_definitions */
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::class_method_definitions */
#if BIND_<%= self['ruby_name'] %>_INITIALIZE
  mrb_define_method(mrb, <%= self['ruby_name'] %>_class, "initialize", mrb_<%= module_name %>_<%= self['ruby_name'] %>_initialize, MRB_ARGS_NONE());
#endif
/* MRUBY_BINDING_END */

<% if self['fields'].any? -%>
/* MRUBY_BINDING: <%= self['ruby_name'] %>::pre_attr_definitions */
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::attr_definitions */
  /*
   * Fields
   */
<%   self['fields'].select { |f| f['access'] == 'public' }.each do |field| -%>
#if BIND_<%= self['ruby_name'] %>_<%= field['name'] %>_FIELD_READER
  mrb_define_method(mrb, <%= self['ruby_name'] %>_class, "<%= field['name'] %>", mrb_<%= module_name %>_<%= self['ruby_name'] %>_get_<%= field['name'] %>, MRB_ARGS_ARG(0, 0));
#endif
#if BIND_<%= self['ruby_name'] %>_<%= field['name'] %>_FIELD_WRITER
  mrb_define_method(mrb, <%= self['ruby_name'] %>_class, "<%= field['name'] %>=", mrb_<%= module_name %>_<%= self['ruby_name'] %>_set_<%= field['name'] %>, MRB_ARGS_ARG(1, 0));
#endif
<%   end -%>
/* MRUBY_BINDING_END */
<% end -%>

<% if self['member_functions'].any? -%>
/* MRUBY_BINDING: <%= self['ruby_name'] %>::pre_instance_method_definitions */
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::instance_method_definitions */
  /*
   * Member Functions
   */
<%   self['member_functions'].each do |function| -%>
#if BIND_<%= self['ruby_name'] %>_<%= function['name'] %>_FUNCTION
  mrb_define_method(mrb, <%= self['ruby_name'] %>_class, "<%= function['name'] %>", mrb_<%= module_name %>_<%= self['ruby_name'] %>_<%= function['name'] %>, <%= self['ruby_name'] %>_<%= function['name'] %>_REQUIRED_ARGC, <%= self['ruby_name'] %>_<%= function['name'] %>_OPTIONAL_ARGC));
#endif
<%   end -%>
/* MRUBY_BINDING_END */
<% end -%>

/* MRUBY_BINDING: <%= self['ruby_name'] %>::post_class_definition */
/* MRUBY_BINDING_END */
}

/* MRUBY_BINDING: footer */
/* MRUBY_BINDING_END */
#endif
