/*
 * <%= self['type']['type_name'] %>
 * Defined in file <%= File.basename self['file'] %> @ line <%= self['line'] %>
 */

#include "mruby_<%= module_name %>.h"

#if BIND_<%= self['ruby_name'] %>_TYPE

/* MRUBY_BINDING: header */
/* MRUBY_BINDING_END */

/*
 * Class Methods
 */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::initialize */
#if BIND_<%= self['ruby_name'] %>_INITIALIZE
mrb_value
mrb_<%= module_name %>_<%= self['ruby_name'] %>_initialize(mrb_state* mrb, mrb_value self) {
<% # TODO: Add CTypes.set_initializer as dual of CTypes.set_destructor -%>
/* TODO: Uncomment (and optionally replace) if an initializer is desired.
  <%= self['type']['type_name'] %>* native_object = (<%= self['type']['type_name'] %>*)calloc(1, sizeof(<%= self['type']['type_name'] %>));
  mruby_gift_<%= MRubyBindings.type_name_to_id(self['name']) %>_data_ptr(self, native_object);
  return self;
*/
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::disown */
mrb_value
mrb_<%= module_name %>_<%= self['ruby_name'] %>_disown(mrb_state* mrb, mrb_value self) {
  mrb_value ruby_object;
  mrb_get_args(mrb, "o", &ruby_object);

  if (!mrb_obj_is_kind_of(mrb, ruby_object, mrb_class_ptr(self))) {
    mrb_raise(mrb, E_TYPE_ERROR, "<%= module_name %>::<%= self['ruby_name'] %>.disown only accepts objects of type <%= module_name %>::<%= self['ruby_name'] %>");
    return mrb_nil_value();
  }

  ((mruby_to_native_ref*)(DATA_PTR(ruby_object)))->belongs_to_ruby = FALSE;

  return mrb_nil_value();
}
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::belongs_to_ruby */
mrb_value
mrb_<%= module_name %>_<%= self['ruby_name'] %>_belongs_to_ruby(mrb_state* mrb, mrb_value self) {
  mrb_value ruby_object;
  mrb_get_args(mrb, "o", &ruby_object);

  if (!mrb_obj_is_kind_of(mrb, ruby_object, mrb_class_ptr(self))) {
    mrb_raise(mrb, E_TYPE_ERROR, "<%= module_name %>::<%= self['ruby_name'] %>.belongs_to_ruby only accepts objects of type <%= module_name %>::<%= self['ruby_name'] %>");
    return mrb_nil_value();
  }

  if ( ((mruby_to_native_ref*)(DATA_PTR(ruby_object)))->belongs_to_ruby ) {
    return mrb_true_value();
  } else {
    return mrb_false_value();
  }
}
/* MRUBY_BINDING_END */

<% if self['fields'].any? -%>
/*
 * Fields
 */

<%   self['fields'].select { |f| f['access'] == 'public' }.each do |field| -%>
/* MRUBY_BINDING: <%= self['ruby_name'] %>::<%= field['name'] %>_reader */
#if BIND_<%= self['ruby_name'] %>_<%= field['name'] %>_FIELD_READER
/* get_<%= field['name'] %>
 *
 * Return Type: <%= field['type']['type_name'] %>
 */
mrb_value
mrb_<%= module_name %>_<%= self['ruby_name'] %>_get_<%= field['name'] %>(mrb_state* mrb, mrb_value self) {
  <%= self['type']['type_name'] %> * native_self = mruby_unbox_<%= MRubyBindings.type_name_to_id(self['type']['type_name']) %>(self);

  <%= field['type']['type_name'] %> <%= field['ctype'].native_name(field['name']) %> = native_self-><%= field['name'] %>;

<%    field['ctype'].box(field['name']).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%    end -%>

  return <%= field['ctype'].ruby_name(field['name']) %>;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::<%= field['name'] %>_writer */
#if BIND_<%= self['ruby_name'] %>_<%= field['name'] %>_FIELD_WRITER
/* set_<%= field['name'] %>
 *
 * Parameters:
 * - value: <%= field['type']['type_name'] %>
 */
mrb_value
mrb_<%= module_name %>_<%= self['ruby_name'] %>_set_<%= field['name'] %>(mrb_state* mrb, mrb_value self) {
  <%= self['type']['type_name'] %> * native_self = mruby_unbox_<%= MRubyBindings.type_name_to_id(self['type']['type_name']) %>(self);
<%       field['ctype'].recv(field['name']).each_line do |line| -%>
  <%= line.sub("\n", '') %>
<%     end -%>

  mrb_get_args(mrb, "<%= field['ctype'].format_specifier %>", <%= field['ctype'].get_args_argv(field['name']) %>);

<% if field['ctype'].needs_type_check? -%>
  /* type checking */
<%    field['ctype'].type_check(field['name']).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%    end -%>

<%  end -%>
<% if field['ctype'].needs_unboxing? -%>
<%     field['ctype'].unbox(field['name']).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%     end -%>

<%   end -%>
<% field['ctype'].swap_fields("native_self->#{field['name']}", field['ctype'].native_name(field['name'])).each_line do |line| -%>
  <%= line.sub("\n", '') %>
<% end -%>
  
<% -%>
<% # Note: Don't do the unboxing cleanup. The native value is definitely still referenced by the underlying struct -%>
<% -%>
  mrb_value value_as_mrb_value;
  mrb_get_args(mrb, "o", &value_as_mrb_value);
  return value_as_mrb_value;
}
#endif
/* MRUBY_BINDING_END */

<%   end -%>
<% end -%>

<% if self['member_functions'].any? -%>
/*
 * Methods
 */

<%   self['member_functions'].select { |f| f['access'] == 'public' }.each do |function| -%>
/* MRUBY_BINDING: <%= self['ruby_name'] %>::<%= function['name'] %> */
#if BIND_<%= self['ruby_name'] %>_<%= function['name'] %>_FUNCTION
#define <%= self['ruby_name'] %>_<%= function['name'] %>_REQUIRED_ARGC <%= function['argc'] %>
#define <%= self['ruby_name'] %>_<%= function['name'] %>_OPTIONAL_ARGC 0
/* <%= function['name'] %>
 *
 * Parameters:<%= " None" unless function['params'].any? %>
<%   if function['params'].any? -%>
<%     function['params'].each do |param| -%>
 * - <%= param['name'] %>: <%= param['type']['type_name'] %>
<%     end -%>
<%   end -%>
 * Return Type: <%= function['return_type']['type_name'] %>
 */
mrb_value
mrb_<%= module_name %>_<%= self['ruby_name'] %>_<%= function['name'] %>(mrb_state* mrb, mrb_value self) {
  <%= self['type']['type_name'] %> * native_self = mruby_unbox_<%= self['type']['type_name'] %>(self);

<%   if function['params'].any? -%>
<%     function['params'].each do |param| -%>
  mrb_value <%= param['name'] %>;
<%     end -%>

/* Fetch the args */
  mrb_get_args(mrb, "<%= 'o' * function['params'].length %>", <%= function['params'].map { |p| "&#{p['name']}" }.join(', ') %>);

<%     if function['params'].any? %>
  /* Type checking */
<%       function['params'].each do |param| -%>
<%         (CTypes[param['type']['type_name']].type_check_template % ({:value => param['name']})).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%         end -%>
<%       end -%>
<%     end -%>

<%     if function['params'].any? %>
  /* Unbox parameters */
<%       function['params'].each do |param| -%>
<%         (CTypes[param['type']['type_name']].unboxing_fn.invocation_template % ({:unbox => param['name'], :as => "native_#{param['name']}"})).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%         end -%>

<%       end -%>
<%     end -%>
<%   end -%>
  /* Invocation */
  <%= function['return_type']['type_name'] == 'void' ? '' : "#{function['return_type']['type_name']} result = " %>native_self-><%= function['name'] %>(<%= function['params'].map { |p| "native_#{p['name']}" }.join(', ') %>);

<%   if function['return_type']['type_name'] != 'void' -%>
  /* Box the return value */
<%     (CTypes[function['return_type']['type_name']].boxing_fn.invocation_template % ({:box => 'result', :as => 'return_value'})).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%     end -%>

<%   end -%>
<%   function['params'].each do |param| -%>
<%     if CTypes[param['type']['type_name']].unboxing_fn.cleanup_template -%>
<%       (CTypes[param['type']['type_name']].unboxing_fn.cleanup_template % ({:value => "native_#{param['name']}"})).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%       end -%>

<%     end -%>
<%   end -%>
<%   if function['return_type']['type_name'] == 'void' -%>
  return mrb_nil_value();
<%   else -%>
  return return_value;
<%   end -%>
}
#endif
/* MRUBY_BINDING_END */

<%   end -%>
<% end -%>
void mrb_<%= module_name %>_<%= self['ruby_name'] %>_init(mrb_state* mrb) {
/* MRUBY_BINDING: <%= self['ruby_name'] %>::class_init_header */
  /* Don't double-init. */
  static int initialized = 0;
  if (initialized) return;
  else initialized = 1;
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::class_definition */
  struct RClass* <%= self['ruby_name'] %>_class = mrb_define_class_under(mrb, <%= module_name %>_module(mrb), "<%= self['ruby_name'] %>", mrb->object_class);
  MRB_SET_INSTANCE_TT(<%= self['ruby_name'] %>_class, MRB_TT_DATA);
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::pre_class_method_definitions */
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::class_method_definitions */
#if BIND_<%= self['ruby_name'] %>_INITIALIZE
  mrb_define_method(mrb, <%= self['ruby_name'] %>_class, "initialize", mrb_<%= module_name %>_<%= self['ruby_name'] %>_initialize, MRB_ARGS_NONE());
#endif
  mrb_define_class_method(mrb, <%= self['ruby_name'] %>_class, "disown", mrb_<%= module_name %>_<%= self['ruby_name'] %>_disown, MRB_ARGS_ARG(1, 0));
  mrb_define_class_method(mrb, <%= self['ruby_name'] %>_class, "belongs_to_ruby?", mrb_<%= module_name %>_<%= self['ruby_name'] %>_belongs_to_ruby, MRB_ARGS_ARG(1, 0));
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::pre_attr_definitions */
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::attr_definitions */
  /*
   * Fields
   */
<% if self['fields'].any? -%>
<%   self['fields'].select { |f| f['access'] == 'public' }.each do |field| -%>
#if BIND_<%= self['ruby_name'] %>_<%= field['name'] %>_FIELD_READER
  mrb_define_method(mrb, <%= self['ruby_name'] %>_class, "<%= field['name'] %>", mrb_<%= module_name %>_<%= self['ruby_name'] %>_get_<%= field['name'] %>, MRB_ARGS_ARG(0, 0));
#endif
#if BIND_<%= self['ruby_name'] %>_<%= field['name'] %>_FIELD_WRITER
  mrb_define_method(mrb, <%= self['ruby_name'] %>_class, "<%= field['name'] %>=", mrb_<%= module_name %>_<%= self['ruby_name'] %>_set_<%= field['name'] %>, MRB_ARGS_ARG(1, 0));
#endif
<%   end -%>
<% else -%>
  /* None */
<% end -%>
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::pre_instance_method_definitions */
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::instance_method_definitions */
  /*
   * Member Functions
   */
<% if self['member_functions'].any? -%>
<%   self['member_functions'].each do |function| -%>
#if BIND_<%= self['ruby_name'] %>_<%= function['name'] %>_FUNCTION
  mrb_define_method(mrb, <%= self['ruby_name'] %>_class, "<%= function['name'] %>", mrb_<%= module_name %>_<%= self['ruby_name'] %>_<%= function['name'] %>, <%= self['ruby_name'] %>_<%= function['name'] %>_REQUIRED_ARGC, <%= self['ruby_name'] %>_<%= function['name'] %>_OPTIONAL_ARGC));
#endif
<%   end -%>
<% else -%>
  /* None */
<% end -%>
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: <%= self['ruby_name'] %>::class_init_footer */
/* MRUBY_BINDING_END */
}

/* MRUBY_BINDING: footer */
/* MRUBY_BINDING_END */
#endif
