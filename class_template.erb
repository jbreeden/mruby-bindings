/*
 * <%= self['type']['type_name'] %>
 * Defined in file <%= File.basename self['file'] %> @ line <%= self['line'] %>
 */

/*
 * TODO: INCLUDES
 */

#include "mruby_<%= module_name %>.h"

#if BIND_<%= self['ruby_name'] %>_TYPE

/*
 * Class Methods
 */

#if BIND_<%= self['ruby_name'] %>_INITIALIZE
mrb_value
mrb_<%= module_name %>_<%= self['ruby_name'] %>_initialize(mrb_state* mrb, mrb_value self) {
  <%= self['type']['type_name'] %>* native_object = (<%= self['type']['type_name'] %>*)malloc(sizeof(<%= self['type']['type_name'] %>));
  mruby_gift_<%= self['name'] %>_data_ptr(self, native_object);
  return self;
}
#endif

mrb_value
mrb_<%= module_name %>_<%= self['ruby_name'] %>_disown(mrb_state* mrb, mrb_value self) {
  mrb_value ruby_object;
  mrb_get_args(mrb, "o", &ruby_object);

  if (!mrb_obj_is_kind_of(mrb, ruby_object, mrb_class_ptr(self))) {
    mrb_raise(mrb, E_TYPE_ERROR, "<%= module_name %>::<%= self['ruby_name'] %>.disown only accepts objects of type <%= module_name %>::<%= self['ruby_name'] %>");
    return mrb_nil_value();
  }

  ((mruby_to_native_ref*)(DATA_PTR(ruby_object)))->belongs_to_ruby = FALSE;

  return mrb_nil_value();
}

mrb_value
mrb_<%= module_name %>_<%= self['ruby_name'] %>_belongs_to_ruby(mrb_state* mrb, mrb_value self) {
  mrb_value ruby_object;
  mrb_get_args(mrb, "o", &ruby_object);

  if (!mrb_obj_is_kind_of(mrb, ruby_object, mrb_class_ptr(self))) {
    mrb_raise(mrb, E_TYPE_ERROR, "<%= module_name %>::<%= self['ruby_name'] %>.disown only accepts objects of type <%= module_name %>::<%= self['ruby_name'] %>");
    return mrb_nil_value();
  }

  if ( ((mruby_to_native_ref*)(DATA_PTR(ruby_object)))->belongs_to_ruby ) {
    return mrb_true_value();
  } else {
    return mrb_false_value();
  }
}

<% if self['fields'].any? -%>
/*
 * Fields
 */

<%   self['fields'].select { |f| f['access'] == 'public' }.each do |field| -%>
#if BIND_<%= self['ruby_name'] %>_<%= field['name'] %>_FIELD
/* get_<%= field['name'] %>
 *
 * Return Type: <%= field['type']['type_name'] %>
 */
mrb_value
mrb_<%= module_name %>_<%= self['ruby_name'] %>_get_<%= field['name'] %>(mrb_state* mrb, mrb_value self) {
  <%= self['type']['type_name'] %> * native_self = mruby_unbox_<%= self['type']['type_name'] %>(self);

  <%= field['type']['type_name'] %> native_field = native_self-><%= field['name'] %>;

<%    (CTypes[field['type']['type_name']].boxing_fn.invocation_template % ({:box => 'native_field', :as => 'ruby_field'})).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%    end -%>
  /* Store the ruby object to prevent garage collection of the underlying native object */
  mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "@<%= field['name'] %>_box"), ruby_field);

  return ruby_field;
}

/* set_<%= field['name'] %>
 *
 * Parameters:
 * - value: <%= field['type']['type_name'] %>
 */
mrb_value
mrb_<%= module_name %>_<%= self['ruby_name'] %>_set_<%= field['name'] %>(mrb_state* mrb, mrb_value self) {
  <%= self['type']['type_name'] %> * native_self = mruby_unbox_<%= self['type']['type_name'] %>(self);
  mrb_value ruby_field;

  mrb_get_args(mrb, "o", &ruby_field);

  /* type checking */
<%  (CTypes[field['type']['type_name']].type_check % ({:value => 'ruby_field'})).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%  end -%>

  /* Store the ruby object to prevent garage collection of the underlying native object */
  mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "@<%= field['name'] %>_box"), ruby_field);

<%   (CTypes[field['type']['type_name']].unboxing_fn.invocation_template % ({:unbox => 'ruby_field', :as => 'native_field'})).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%   end -%>

  native_self-><%= field['name'] %> = native_field;

  return ruby_field;
}
#endif

<%   end -%>
<% end -%>

<% if self['member_functions'].any? -%>
/*
 * Methods
 */

<%   self['member_functions'].select { |f| f['access'] == 'public' }.each do |function| -%>
#if BIND_<%= self['ruby_name'] %>_<%= function['name'] %>_FUNCTION
#define <%= self['ruby_name'] %>_<%= function['name'] %>_REQUIRED_ARGC <%= function['argc'] %>
#define <%= self['ruby_name'] %>_<%= function['name'] %>_OPTIONAL_ARGC 0
/* <%= function['name'] %>
 *
 * Parameters:<%= " None" unless function['params'].any? %>
<%   if function['params'].any? -%>
<%     function['params'].each do |param| -%>
 * - <%= param['name'] %>: <%= param['type']['type_name'] %>
<%     end -%>
<%   end -%>
 * Return Type: <%= function['return_type']['type_name'] %>
 */
mrb_value
mrb_<%= module_name %>_<%= self['ruby_name'] %>_<%= function['name'] %>(mrb_state* mrb, mrb_value self) {
  <%= self['type']['type_name'] %> * native_self = mruby_unbox_<%= self['type']['type_name'] %>(self);

<%   if function['params'].any? -%>
<%     function['params'].each do |param| -%>
  mrb_value <%= param['name'] %>;
<%     end -%>

/* Fetch the args */
  mrb_get_args(mrb, "<%= 'o' * function['params'].length %>", <%= function['params'].map { |p| "&#{p['name']}" }.join(', ') %>);

<%     if function['params'].any? %>
  /* Type checking */
<%       function['params'].each do |param| -%>
<%         (CTypes[param['type']['type_name']].type_check % ({:value => param['name']})).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%         end -%>
<%       end -%>
<%     end -%>

<%     if function['params'].any? %>
  /* Unbox parameters */
<%       function['params'].each do |param| -%>
<%         (CTypes[param['type']['type_name']].unboxing_fn.invocation_template % ({:unbox => param['name'], :as => "native_#{param['name']}"})).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%         end -%>

<%       end -%>
<%     end -%>
<%   end -%>
  /* Invocation */
  <%= function['return_type']['type_name'] == 'void' ? '' : "#{function['return_type']['type_name']} result = " %>native_self-><%= function['name'] %>(<%= function['params'].map { |p| "native_#{p['name']}" }.join(', ') %>);

<%   if function['return_type']['type_name'] != 'void' -%>
  /* Box the return value */
<%     (CTypes[function['return_type']['type_name']].boxing_fn.invocation_template % ({:box => 'result', :as => 'return_value'})).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%     end -%>

<%   end -%>
<%   function['params'].each do |param| -%>
<%     if CTypes[param['type']['type_name']].unboxing_fn.param_cleanup_template -%>
<%       (CTypes[param['type']['type_name']].unboxing_fn.param_cleanup_template % ({:clean => "native_#{param['name']}"})).each_line do |line| -%>
  <%= line.sub("\n", "") %>
<%       end -%>

<%     end -%>
<%   end -%>
<%   if function['return_type']['type_name'] == 'void' -%>
  return mrb_nil_value();
<%   else -%>
  return return_value;
<%   end -%>
}
#endif

<%   end -%>
<% end -%>
void mrb_<%= module_name %>_<%= self['ruby_name'] %>_init(mrb_state* mrb) {
  RClass* <%= self['ruby_name'] %>_class = mrb_define_class_under(mrb, <%= module_name %>_module(mrb), "<%= self['ruby_name'] %>", mrb->object_class);
  MRB_SET_INSTANCE_TT(<%= self['ruby_name'] %>_class, MRB_TT_DATA);

#if BIND_<%= self['ruby_name'] %>_INITIALIZE
  mrb_define_method(mrb, <%= self['ruby_name'] %>_class, "initialize", mrb_<%= module_name %>_<%= self['ruby_name'] %>_initialize, MRB_ARGS_NONE());
#endif
  mrb_define_class_method(mrb, <%= self['ruby_name'] %>_class, "disown", mrb_<%= module_name %>_<%= self['ruby_name'] %>_disown, MRB_ARGS_ARG(1, 0));
  mrb_define_class_method(mrb, <%= self['ruby_name'] %>_class, "belongs_to_ruby?", mrb_<%= module_name %>_<%= self['ruby_name'] %>_belongs_to_ruby, MRB_ARGS_ARG(1, 0));

<% if self['fields'].any? -%>
  /*
   * Fields
   */
<%   self['fields'].select { |f| f['access'] == 'public' }.each do |field| -%>
#if BIND_<%= self['ruby_name'] %>_<%= field['name'] %>_FIELD
  mrb_define_method(mrb, <%= self['ruby_name'] %>_class, "<%= field['name'] %>", mrb_<%= module_name %>_<%= self['ruby_name'] %>_get_<%= field['name'] %>, MRB_ARGS_ARG(0, 0));
  mrb_define_method(mrb, <%= self['ruby_name'] %>_class, "<%= field['name'] %>=", mrb_<%= module_name %>_<%= self['ruby_name'] %>_set_<%= field['name'] %>, MRB_ARGS_ARG(1, 0));
#endif
<%   end -%>
<% end -%>

<% if self['member_functions'].any? -%>
  /*
   * Member Functions
   */
<%   self['member_functions'].each do |function| -%>
#if BIND_<%= self['ruby_name'] %>_<%= function['name'] %>_FUNCTION
  mrb_define_method(mrb, <%= self['ruby_name'] %>_class, "<%= function['name'] %>", mrb_<%= module_name %>_<%= self['ruby_name'] %>_<%= function['name'] %>, <%= self['ruby_name'] %>_<%= function['name'] %>_REQUIRED_ARGC, <%= self['ruby_name'] %>_<%= function['name'] %>_OPTIONAL_ARGC));
#endif
<%   end -%>
<% end -%>
}

#endif
